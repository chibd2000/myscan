# coding=utf-8
# @Author   : zpchcbd HG team
# @Time     : 2021-08-27 18:36
from async_timeout import timeout

from exploit.service.base import *


async def checkUnauth(addr):
    try:
        with timeout(5):
            reader, writer = await asyncio.open_connection(addr.split(':')[0], int(addr.split(':')[1]))
            writer.write(b'@RSYNCD: 31\n')
            await writer.drain()
            await reader.read(1024)
            writer.write(b'\n')
            await writer.drain()
            result = await reader.read(1024)
            for path_name in re.split('\n', result.decode()):
                print(path_name)
                if path_name and '@RSYNCD: EXIT' not in path_name:
                    return {'name': 'unauth', 'url': addr, 'software': 'rsync'}
            # writer.write(bytes.fromhex(message))
            # await writer.drain()
            # result2 = await reader.read(1024)
            # print(result2)
    except:
        pass
    finally:
        try:
            writer.close()
        except NameError:
            pass


async def checkWeakPass(addr):
    pass
    # try:
    #     payload1 = struct.pack("!8s5ss", bytes("@RSYNCD:", 'utf-8'), bytes(" 30.0", 'utf-8'), bytes("\r\n", 'utf-8'))
    #     payload2 = (cmd + '\r\n').encode('utf-8')
    #     usernamedic = self.read_file(self.parameter['U']) if 'U' in self.parameter.keys() else self.read_file(
    #         os.path.join(paths.DICT_PATH, 'rsync_usernames.txt'))
    #     passworddic = self.read_file(self.parameter['P']) if 'P' in self.parameter.keys() else self.read_file(
    #         os.path.join(paths.DICT_PATH, 'rsync_passwords.txt'))
    #
    #     for (username, password) in self.generate_dict(usernamedic, passworddic):
    #         try:
    #             reader1, writer1 = await open_connection(self.target_host, self.target_port)
    #             writer1.write(payload1)
    #
    #             message = '\r\n'
    #             writer1.write(message.encode('utf-8'))
    #
    #             data1 = await reader1.read(1024)
    #             data1 = data1.decode('utf-8')
    #             writer1.write(payload2)
    #
    #             message = '\r\n'
    #             writer1.write(message.encode('utf-8'))
    #
    #             data2 = await reader1.read(1024)
    #             data2 = data2.decode('utf-8').replace("\n", "")  # data  @RSYNCD: AUTHREQD 9moobOy1VMjNAU/D4PB35g
    #
    #             if data2 and 'AUTHREQD ' in data2:
    #                 challenge = data2[18:-1]  # get challenge code
    #                 md = hashlib.md5()
    #                 md.update(password.encode('utf-8'))
    #                 md.update(challenge.encode('utf-8'))
    #                 auth_send_data = base64.encodebytes(md.digest())
    #                 payload3 = "%s %s\r\n" % (username, auth_send_data[:-3])
    #
    #                 writer1.write(payload3.encode('utf-8'))
    #                 data3 = (await reader1.read(1024)).decode('utf-8')  # @RSYNCD: OK
    #
    #                 writer1.close()
    #                 if 'OK' in data3:
    #                     return cmd, username, password
    #             else:
    #                 writer1.close()
    #         except:
    #             writer1.close()
    #             pass
    # except:
    #     pass
    # finally:
    #     try:
    #         writer.close()
    #     except NameError:
    #         pass


async def rsyncScan(addr, pbar):
    vulList = []
    a = await checkUnauth(addr)
    if a is not None:
        vulList.append(a)
    b = await checkWeakPass(addr)
    if b is not None:
        vulList.append(b)
    # vulList.append(b)
    return vulList


if __name__ == '__main__':
    t = asyncio.run(rsyncScan('192.168.4.137:873'))
    print(t)
