# coding=utf-8
# @Author   : zpchcbd HG team
# @Blog     : https://www.cnblogs.com/zpchcbd/
# @Time     : 2022-08-07 20:21

from core.data import gLogger
from exploit.scripts import BaseScript
from core.myenums import BugType, BugLevel
from core.request.asynchttp import *


class Script(BaseScript):
    name = 'Druid'

    def __init__(self, target):
        super().__init__()
        # 漏洞目标
        self.target = target
        # 漏洞等级
        self.bug_level = BugLevel.HIGH
        # 类型
        self.bug_type = BugType.UNAUTH
        # 编号
        self.bug_number = ''
        # 来源
        self.bug_refer = ''
        # 特定路径判断
        self.detect_path_list = self.get_detect_path()
        # exec
        self.exec_path_list = []
        # 相关信息
        self.info = 'druid未授权访问导致相关sql语句寻找order by注入点以及session泄露导致任意用户登录'

    def get_detect_path(self):
        path_a = ['console.html', 'sql.html', 'index.html']
        path_b = ['/', '/druid/', '/server/druid/', '/api/druid', '/app/druid/', '/api/app/druid/', '/api/saas/apisvr/druid/']
        for a in path_a:
            for b in path_b:
                yield b+a

    async def detect(self):
        async with aiohttp.ClientSession() as session:
            for detect_path in self.detect_path_list:
                url = f'http://{self.target}{detect_path}' if self.target.startswith(('http:', 'https:')) is False else f'{self.target}{detect_path}'
                text = await AsyncFetcher.fetch(session=session, url=url, headers=self.headers, timeout=10)
                text = text.lower()
                if text is not None and ('druid stat index' in text
                                         or 'druid version' in text
                                         or 'druid indexer' in text
                                         or 'druid sql stat' in text
                                         or 'druid monitor' in text):
                    self.flag = True
                    gLogger.myscan_info('[{} {}] {}'.format(self.name, BugType.FINGER, url))
                    return {'name': '{} {}'.format(self.name, BugType.FINGER), 'url': url, 'software': self.name}


if __name__ == '__main__':
    pass
